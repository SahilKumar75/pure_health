import 'package:flutter/material.dart';
import 'package:pure_health/core/constants/color_constants.dart';
import 'package:pure_health/core/theme/text_styles.dart';
import 'package:pure_health/core/models/station_models.dart';
import 'package:pure_health/core/utils/cpcb_wqi_calculator.dart';
import 'package:pure_health/core/services/local_storage_service.dart';
import 'package:pure_health/core/services/realtime_websocket_service.dart';
import 'package:pure_health/features/ai_analysis/data/services/station_ai_service.dart';
import 'package:pure_health/features/ai_analysis/data/services/historical_disease_data_service.dart';
import 'package:pure_health/shared/widgets/custom_sidebar.dart';
import 'package:fl_chart/fl_chart.dart';
import 'dart:async';

/// Unified Station Dashboard - Phase 4 Implementation
/// 
/// A comprehensive, single-screen dashboard that combines:
/// - Water quality analysis
/// - Predictions (7/30/90-day forecasts)
/// - Risk analysis (water + health)
/// - Trends and historical data
/// - Health impact and disease predictions
/// - Recommendations
/// 
/// Design: Modern web-optimized tabbed interface with cards
class UnifiedStationDashboard extends StatefulWidget {
  final String stationId;
  final WaterQualityStation station;
  final StationData? currentReading; // Current reading data

  const UnifiedStationDashboard({
    super.key,
    required this.stationId,
    required this.station,
    this.currentReading,
  });

  @override
  State<UnifiedStationDashboard> createState() => _UnifiedStationDashboardState();
}

class _UnifiedStationDashboardState extends State<UnifiedStationDashboard>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _selectedSidebarIndex = 3; // AI Analysis
  bool _isLoading = false;
  
  // Services
  StationAIService? _aiService;
  final _diseaseService = HistoricalDiseaseDataService();
  // LocalStorageService? _storageService;
  // RealtimeWebSocketService? _wsService; // TODO: Re-enable after Phase 6 testing
  
  // Stream subscriptions
  StreamSubscription<Map<String, dynamic>>? _stationUpdateSubscription;
  StreamSubscription<Map<String, dynamic>>? _alertSubscription;
  StreamSubscription<Map<String, dynamic>>? _predictionSubscription;
  StreamSubscription<bool>? _connectionSubscription;
  
  // Data
  StationData? _latestReading;
  Map<String, dynamic>? _predictions;
  Map<String, dynamic>? _riskAnalysis;
  List<StationData>? _historicalData;
  bool _isMLBackendAvailable = false;
  bool _isRealtimeConnected = false;
  List<Map<String, dynamic>> _realtimeAlerts = [];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 6, vsync: this);
    _initializeData();
  }

  @override
  void dispose() {
    _tabController.dispose();
    _stationUpdateSubscription?.cancel();
    _alertSubscription?.cancel();
    _predictionSubscription?.cancel();
    _connectionSubscription?.cancel();
    _wsService?.dispose();
    super.dispose();
  }

  Future<void> _initializeData() async {
    setState(() => _isLoading = true);

    try {
      // Initialize services
      _aiService = StationAIService();
      // _storageService = await LocalStorageService.getInstance();
      _isMLBackendAvailable = await _aiService!.testConnection();

      // Initialize WebSocket for real-time updates
      // TODO: Re-enable after Phase 6 testing
      // await _initializeWebSocket();

      // Get latest reading (use provided or fetch from storage)
      _latestReading = widget.currentReading;
      
      // TODO: Re-enable storage service after Phase 6 testing
      // if (_latestReading == null) {
      //   // Try to fetch from storage
      //   final history = await _storageService!.getStationHistory(widget.stationId);
      //   if (history.isNotEmpty) {
      //     _latestReading = history.last;
      //   }
      // }

      // TODO: Re-enable predictions after API updates
      // Load predictions if ML backend available
      // if (_isMLBackendAvailable && _latestReading != null) {
      //   try {
      //     _predictions = await _aiService!.getAIPredictions(
      //       widget.stationId,
      //       days: 30, // 30-day forecast
      //     );
      //   } catch (e) {
      //     print('[UNIFIED_DASHBOARD] Prediction error: $e');
      //   }
      // }

      // TODO: Get historical data (last 30 days)
      // final history = await _storageService!.getStationHistory(widget.stationId);
      // _historicalData = history.where((r) {
      //   try {
      //     final timestamp = DateTime.parse(r.timestamp);
      //     return timestamp.isAfter(
      //       DateTime.now().subtract(const Duration(days: 30))
      //     );
      //   } catch (e) {
      //     return false;
      //   }
      // }).toList();
      
    } catch (e) {
      print('[UNIFIED_DASHBOARD] Error initializing: $e');
    }

    setState(() => _isLoading = false);
  }

  /// Initialize WebSocket connection for real-time updates
  /// TODO: Re-enable after Phase 6 testing
  /*
  Future<void> _initializeWebSocket() async {
    try {
      _wsService = RealtimeWebSocketService();
      
      // Connect to WebSocket server (adjust host/port as needed)
      final connected = await _wsService!.connect(
        host: 'localhost:8080',
        stationId: widget.stationId,
      );
      
      if (connected) {
        print('[UNIFIED_DASHBOARD] WebSocket connected for station ${widget.stationId}');
        
        // Listen to connection status
        _connectionSubscription = _wsService!.connectionStatus.listen((isConnected) {
          setState(() {
            _isRealtimeConnected = isConnected;
          });
          print('[UNIFIED_DASHBOARD] WebSocket connection: $isConnected');
        });
        
        // Listen to station updates
        _stationUpdateSubscription = _wsService!.stationUpdates.listen((data) {
          print('[UNIFIED_DASHBOARD] Received station update: $data');
          _handleStationUpdate(data);
        });
        
        // Listen to alerts
        _alertSubscription = _wsService!.alerts.listen((alert) {
          print('[UNIFIED_DASHBOARD] Received alert: ${alert['message']}');
          _handleAlert(alert);
        });
        
        // Listen to prediction updates
        _predictionSubscription = _wsService!.predictions.listen((predictions) {
          print('[UNIFIED_DASHBOARD] Received prediction update');
          _handlePredictionUpdate(predictions);
        });
      } else {
        print('[UNIFIED_DASHBOARD] WebSocket connection failed');
      }
    } catch (e) {
      print('[UNIFIED_DASHBOARD] WebSocket initialization error: $e');
    }
  }

  /// Handle real-time station data update
  void _handleStationUpdate(Map<String, dynamic> data) {
    try {
      // Create StationData from WebSocket data
      final parameters = {
        'ph': data['ph'] ?? 7.0,
        'dissolvedOxygen': data['do'] ?? 5.0,
        'biochemicalOxygenDemand': data['bod'] ?? 3.0,
        'fecalColiform': data['fc'] ?? 500.0,
        'totalDissolvedSolids': data['tds'] ?? 300.0,
        'temperature': data['temperature'] ?? 25.0,
        'turbidity': data['turbidity'] ?? 5.0,
      };
      
      final wqi = (data['wqi'] as num?)?.toDouble() ?? 50.0;
      final status = data['status'] ?? 'Moderate';
      final waterQualityClass = data['class'] ?? 'C';
      
      final newReading = StationData(
        stationId: widget.stationId,
        timestamp: data['timestamp'] ?? DateTime.now().toIso8601String(),
        wqi: wqi,
        status: status,
        waterQualityClass: waterQualityClass,
        parameters: parameters,
        alerts: data['alerts'] ?? [],
      );
      
      setState(() {
        _latestReading = newReading;
        // Add to historical data
        if (_historicalData != null) {
          _historicalData!.add(newReading);
          // Keep only last 30 days
          final cutoff = DateTime.now().subtract(const Duration(days: 30));
          _historicalData = _historicalData!.where((r) {
            try {
              final timestamp = DateTime.parse(r.timestamp);
              return timestamp.isAfter(cutoff);
            } catch (e) {
              return false;
            }
          }).toList();
        }
      });
      
      // Save to local storage
      _storageService?.saveStationData(widget.stationId, newReading);
      
    } catch (e) {
      print('[UNIFIED_DASHBOARD] Error handling station update: $e');
    }
  }

  /// Handle real-time alert
  void _handleAlert(Map<String, dynamic> alert) {
    setState(() {
      _realtimeAlerts.insert(0, {
        ...alert,
        'receivedAt': DateTime.now().toIso8601String(),
      });
      // Keep only last 10 alerts
      if (_realtimeAlerts.length > 10) {
        _realtimeAlerts = _realtimeAlerts.sublist(0, 10);
      }
    });
    
    // Show alert snackbar
    if (mounted) {
      final severity = alert['severity'] ?? 'warning';
      final color = severity == 'critical' ? Colors.red : 
                    severity == 'high' ? Colors.orange : 
                    Colors.amber;
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(alert['message'] ?? 'Alert received'),
          backgroundColor: color,
          duration: const Duration(seconds: 5),
          action: SnackBarAction(
            label: 'View',
            textColor: Colors.white,
            onPressed: () {
              // Switch to alerts/risk tab
              _tabController.animateTo(2);
            },
          ),
        ),
      );
    }
  }

  /// Handle real-time prediction update
  void _handlePredictionUpdate(Map<String, dynamic> predictions) {
    setState(() {
      _predictions = predictions;
    });
  }

  @override
  Widget build(BuildContext context) {
    return CustomSidebar(
      selectedIndex: _selectedSidebarIndex,
      onMenuItemSelected: (index) {
        setState(() => _selectedSidebarIndex = index);
        // Handle navigation
      },
      child: Scaffold(
        appBar: _buildAppBar(),
        body: _isLoading
            ? const Center(child: CircularProgressIndicator())
            : Column(
                children: [
                  _buildTabBar(),
                  Expanded(
                    child: TabBarView(
                      controller: _tabController,
                      children: [
                        _buildOverviewTab(),
                        _buildPredictionsTab(),
                        _buildRiskAnalysisTab(),
                        _buildTrendsTab(),
                        _buildHealthImpactTab(),
                        _buildRecommendationsTab(),
                      ],
                    ),
                  ),
                ],
              ),
      ),
    );
  }

  PreferredSizeWidget _buildAppBar() {
    return AppBar(
      title: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '${widget.station.name}',
            style: TextStyles.heading.copyWith(fontSize: 20),
          ),
          Row(
            children: [
              Text(
                'Station ID: ${widget.stationId}',
                style: TextStyles.captionGrey.copyWith(fontSize: 12),
              ),
              const SizedBox(width: 8),
              // Real-time status indicator
              if (_isRealtimeConnected) ...[
                Container(
                  width: 8,
                  height: 8,
                  decoration: const BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                  ),
                ),
                const SizedBox(width: 4),
                Text(
                  'LIVE',
                  style: TextStyles.captionGrey.copyWith(
                    fontSize: 10,
                    color: Colors.green,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ] else ...[
                Container(
                  width: 8,
                  height: 8,
                  decoration: const BoxDecoration(
                    color: Colors.grey,
                    shape: BoxShape.circle,
                  ),
                ),
                const SizedBox(width: 4),
                Text(
                  'OFFLINE',
                  style: TextStyles.captionGrey.copyWith(
                    fontSize: 10,
                    color: Colors.grey,
                  ),
                ),
              ],
            ],
          ),
        ],
      ),
      backgroundColor: Colors.white,
      elevation: 0,
      actions: [
        // Real-time alerts badge
        if (_realtimeAlerts.isNotEmpty)
          Stack(
            children: [
              IconButton(
                icon: const Icon(Icons.notifications, color: Colors.black87),
                onPressed: () {
                  _showAlertsDialog();
                },
              ),
              Positioned(
                right: 8,
                top: 8,
                child: Container(
                  padding: const EdgeInsets.all(4),
                  decoration: const BoxDecoration(
                    color: Colors.red,
                    shape: BoxShape.circle,
                  ),
                  child: Text(
                    '${_realtimeAlerts.length}',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ],
          ),
        IconButton(
          icon: const Icon(Icons.refresh, color: Colors.black87),
          onPressed: _initializeData,
        ),
        IconButton(
          icon: const Icon(Icons.share, color: Colors.black87),
          onPressed: () {
            // TODO: Implement share functionality
          },
        ),
        const SizedBox(width: 8),
      ],
    );
  }

  Widget _buildTabBar() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TabBar(
        controller: _tabController,
        labelColor: ColorConstants.primaryColor,
        unselectedLabelColor: Colors.grey,
        indicatorColor: ColorConstants.primaryColor,
        labelStyle: TextStyles.body.copyWith(fontWeight: FontWeight.w600),
        unselectedLabelStyle: TextStyles.body,
        tabs: const [
          Tab(text: 'Overview'),
          Tab(text: 'Predictions'),
          Tab(text: 'Risk Analysis'),
          Tab(text: 'Trends'),
          Tab(text: 'Health Impact'),
          Tab(text: 'Recommendations'),
        ],
      ),
    );
  }

  // ==================== TAB 1: OVERVIEW ====================
  Widget _buildOverviewTab() {
    if (_latestReading == null) {
      return _buildEmptyState('No data available for this station');
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Station Details Card
          _buildStationDetailsCard(),
          const SizedBox(height: 16),
          
          // Current Water Quality Card
          _buildCurrentWQICard(),
          const SizedBox(height: 16),
          
          // Parameters Grid
          _buildParametersGrid(),
        ],
      ),
    );
  }

  Widget _buildStationDetailsCard() {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Station Details', style: TextStyles.title),
            const SizedBox(height: 16),
            _buildDetailRow('Location', widget.station.location),
            _buildDetailRow('Type', widget.station.type),
            _buildDetailRow('Basin', widget.station.basin ?? 'N/A'),
            _buildDetailRow('Status', widget.station.status),
            _buildDetailRow(
              'Last Updated',
              _latestReading != null
                  ? _formatDateTime(_latestReading!.timestamp)
                  : 'No data',
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCurrentWQICard() {
    if (_latestReading == null) return const SizedBox.shrink();

    // Calculate WQI using authentic CPCB calculator
    final wqiResult = CPCBWQICalculator.calculateWQI(
      ph: _latestReading!.ph,
      bod: _latestReading!.biochemicalOxygenDemand,
      dissolvedOxygen: _latestReading!.dissolvedOxygen,
      fecalColiform: _latestReading!.fecalColiform,
      waterTemperature: _latestReading!.temperature,
    );

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Current Water Quality', style: TextStyles.title),
            const SizedBox(height: 20),
            
            // WQI Score
            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  wqiResult.wqi.toStringAsFixed(1),
                  style: TextStyles.heading.copyWith(
                    fontSize: 48,
                    fontWeight: FontWeight.bold,
                    color: _getWQIColor(wqiResult.wqi),
                  ),
                ),
                const SizedBox(width: 12),
                Padding(
                  padding: const EdgeInsets.only(bottom: 8),
                  child: Text(
                    'WQI',
                    style: TextStyles.subtitle.copyWith(color: Colors.grey[600]),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            
            // Classification
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: _getWQIColor(wqiResult.wqi).withOpacity(0.1),
                borderRadius: BorderRadius.circular(20),
              ),
              child: Text(
                wqiResult.classification,
                style: TextStyles.body.copyWith(
                  color: _getWQIColor(wqiResult.wqi),
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            const SizedBox(height: 12),
            
            // Status
            Text(
              wqiResult.status,
              style: TextStyles.caption.copyWith(color: Colors.grey[700]),
            ),
            
            // CPCB Class
            const SizedBox(height: 8),
            Text(
              'CPCB Class: ${wqiResult.classes.cpcbClass}',
              style: TextStyles.caption.copyWith(color: Colors.grey[600]),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildParametersGrid() {
    if (_latestReading == null) return const SizedBox.shrink();

    final parameters = [
      {
        'name': 'pH',
        'value': _latestReading!.ph.toStringAsFixed(1),
        'unit': '',
        'status': _getParameterStatus(_latestReading!.ph, 'ph'),
        'icon': Icons.water_drop,
      },
      {
        'name': 'Dissolved Oxygen',
        'value': _latestReading!.dissolvedOxygen.toStringAsFixed(1),
        'unit': 'mg/l',
        'status': _getParameterStatus(_latestReading!.dissolvedOxygen, 'do'),
        'icon': Icons.bubble_chart,
      },
      {
        'name': 'BOD',
        'value': _latestReading!.biochemicalOxygenDemand.toStringAsFixed(1),
        'unit': 'mg/l',
        'status': _getParameterStatus(_latestReading!.biochemicalOxygenDemand, 'bod'),
        'icon': Icons.science,
      },
      {
        'name': 'Fecal Coliform',
        'value': _latestReading!.fecalColiform.toStringAsFixed(0),
        'unit': 'MPN/100ml',
        'status': _getParameterStatus(_latestReading!.fecalColiform, 'fc'),
        'icon': Icons.coronavirus,
      },
      {
        'name': 'TDS',
        'value': _latestReading!.totalDissolvedSolids.toStringAsFixed(0),
        'unit': 'mg/l',
        'status': _getParameterStatus(_latestReading!.totalDissolvedSolids, 'tds'),
        'icon': Icons.grain,
      },
      {
        'name': 'Turbidity',
        'value': _latestReading!.turbidity.toStringAsFixed(1),
        'unit': 'NTU',
        'status': _getParameterStatus(_latestReading!.turbidity, 'turbidity'),
        'icon': Icons.blur_on,
      },
    ];

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Water Quality Parameters', style: TextStyles.title),
            const SizedBox(height: 16),
            GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 3,
                childAspectRatio: 1.5,
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
              ),
              itemCount: parameters.length,
              itemBuilder: (context, index) {
                final param = parameters[index];
                return _buildParameterCard(
                  param['name'] as String,
                  param['value'] as String,
                  param['unit'] as String,
                  param['status'] as String,
                  param['icon'] as IconData,
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildParameterCard(
    String name,
    String value,
    String unit,
    String status,
    IconData icon,
  ) {
    final statusColor = status == 'Good'
        ? Colors.green
        : status == 'Moderate'
            ? Colors.orange
            : Colors.red;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: statusColor.withOpacity(0.05),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: statusColor.withOpacity(0.2)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              Icon(icon, size: 20, color: statusColor),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  name,
                  style: TextStyles.caption.copyWith(fontWeight: FontWeight.w600),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
          Row(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                value,
                style: TextStyles.subtitle.copyWith(
                  fontWeight: FontWeight.bold,
                  fontSize: 24,
                ),
              ),
              const SizedBox(width: 4),
              Padding(
                padding: const EdgeInsets.only(bottom: 2),
                child: Text(
                  unit,
                  style: TextStyles.caption.copyWith(color: Colors.grey[600]),
                ),
              ),
            ],
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(
              color: statusColor.withOpacity(0.2),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              status,
              style: TextStyles.caption.copyWith(
                color: statusColor,
                fontWeight: FontWeight.w600,
                fontSize: 10,
              ),
            ),
          ),
        ],
      ),
    );
  }

  // ==================== TAB 2: PREDICTIONS ====================
  Widget _buildPredictionsTab() {
    return const Center(
      child: Text('Predictions Tab - Coming Soon'),
    );
  }

  // ==================== TAB 3: RISK ANALYSIS ====================
  Widget _buildRiskAnalysisTab() {
    return const Center(
      child: Text('Risk Analysis Tab - Coming Soon'),
    );
  }

  // ==================== TAB 4: TRENDS ====================
  Widget _buildTrendsTab() {
    if (_historicalData == null || _historicalData!.isEmpty) {
      return _buildEmptyState('No historical data available');
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // WQI Trend Chart
          _buildWQITrendChart(),
          const SizedBox(height: 16),
          
          // Multi-Parameter Chart
          _buildMultiParameterChart(),
          const SizedBox(height: 16),
          
          // Statistics Summary
          _buildStatisticsSummary(),
        ],
      ),
    );
  }

  Widget _buildWQITrendChart() {
    // Prepare WQI data points from historical data
    final wqiDataPoints = <FlSpot>[];
    for (int i = 0; i < _historicalData!.length; i++) {
      final reading = _historicalData![i];
      final wqiResult = CPCBWQICalculator.calculateWQI(
        ph: reading.ph,
        bod: reading.biochemicalOxygenDemand,
        dissolvedOxygen: reading.dissolvedOxygen,
        fecalColiform: reading.fecalColiform,
        waterTemperature: reading.temperature,
      );
      wqiDataPoints.add(FlSpot(i.toDouble(), wqiResult.wqi));
    }

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('WQI Trend (Last 30 Days)', style: TextStyles.title),
            const SizedBox(height: 20),
            SizedBox(
              height: 250,
              child: LineChart(
                LineChartData(
                  gridData: FlGridData(show: true, drawVerticalLine: false),
                  titlesData: FlTitlesData(
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 40,
                        getTitlesWidget: (value, meta) {
                          return Text(
                            value.toInt().toString(),
                            style: TextStyles.caption.copyWith(fontSize: 10),
                          );
                        },
                      ),
                    ),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        interval: wqiDataPoints.length / 5,
                        getTitlesWidget: (value, meta) {
                          if (value.toInt() >= 0 &&
                              value.toInt() < _historicalData!.length) {
                            final date = _historicalData![value.toInt()].timestamp;
                            return Padding(
                              padding: const EdgeInsets.only(top: 8),
                              child: Text(
                                '${date.day}/${date.month}',
                                style: TextStyles.caption.copyWith(fontSize: 10),
                              ),
                            );
                          }
                          return const Text('');
                        },
                      ),
                    ),
                    topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                    rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                  ),
                  borderData: FlBorderData(show: true, border: Border.all(color: Colors.grey[300]!)),
                  lineBarsData: [
                    LineChartBarData(
                      spots: wqiDataPoints,
                      isCurved: true,
                      color: ColorConstants.primaryColor,
                      barWidth: 3,
                      isStrokeCapRound: true,
                      dotData: FlDotData(
                        show: true,
                        getDotPainter: (spot, percent, barData, index) {
                          return FlDotCirclePainter(
                            radius: 3,
                            color: _getWQIColor(spot.y),
                            strokeWidth: 0,
                          );
                        },
                      ),
                      belowBarData: BarAreaData(
                        show: true,
                        color: ColorConstants.primaryColor.withOpacity(0.1),
                      ),
                    ),
                  ],
                  // Add threshold lines
                  extraLinesData: ExtraLinesData(
                    horizontalLines: [
                      HorizontalLine(
                        y: 63,
                        color: Colors.green.withOpacity(0.5),
                        strokeWidth: 1,
                        dashArray: [5, 5],
                        label: HorizontalLineLabel(
                          show: true,
                          alignment: Alignment.topRight,
                          labelResolver: (line) => 'Good (63)',
                          style: TextStyles.caption.copyWith(
                            fontSize: 10,
                            color: Colors.green,
                          ),
                        ),
                      ),
                      HorizontalLine(
                        y: 50,
                        color: Colors.orange.withOpacity(0.5),
                        strokeWidth: 1,
                        dashArray: [5, 5],
                        label: HorizontalLineLabel(
                          show: true,
                          alignment: Alignment.topRight,
                          labelResolver: (line) => 'Medium (50)',
                          style: TextStyles.caption.copyWith(
                            fontSize: 10,
                            color: Colors.orange,
                          ),
                        ),
                      ),
                      HorizontalLine(
                        y: 38,
                        color: Colors.red.withOpacity(0.5),
                        strokeWidth: 1,
                        dashArray: [5, 5],
                        label: HorizontalLineLabel(
                          show: true,
                          alignment: Alignment.topRight,
                          labelResolver: (line) => 'Bad (38)',
                          style: TextStyles.caption.copyWith(
                            fontSize: 10,
                            color: Colors.red,
                          ),
                        ),
                      ),
                    ],
                  ),
                  minY: 0,
                  maxY: 100,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMultiParameterChart() {
    // Prepare data for DO, BOD, pH
    final doDataPoints = <FlSpot>[];
    final bodDataPoints = <FlSpot>[];
    final phDataPoints = <FlSpot>[];

    for (int i = 0; i < _historicalData!.length; i++) {
      final reading = _historicalData![i];
      doDataPoints.add(FlSpot(i.toDouble(), reading.dissolvedOxygen));
      bodDataPoints.add(FlSpot(i.toDouble(), reading.biochemicalOxygenDemand));
      phDataPoints.add(FlSpot(i.toDouble(), reading.ph));
    }

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Key Parameters Trend', style: TextStyles.title),
            const SizedBox(height: 8),
            Row(
              children: [
                _buildLegendItem('DO (mg/l)', Colors.blue),
                const SizedBox(width: 16),
                _buildLegendItem('BOD (mg/l)', Colors.red),
                const SizedBox(width: 16),
                _buildLegendItem('pH', Colors.green),
              ],
            ),
            const SizedBox(height: 20),
            SizedBox(
              height: 250,
              child: LineChart(
                LineChartData(
                  gridData: FlGridData(show: true, drawVerticalLine: false),
                  titlesData: FlTitlesData(
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 40,
                        getTitlesWidget: (value, meta) {
                          return Text(
                            value.toStringAsFixed(1),
                            style: TextStyles.caption.copyWith(fontSize: 10),
                          );
                        },
                      ),
                    ),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        interval: _historicalData!.length / 5,
                        getTitlesWidget: (value, meta) {
                          if (value.toInt() >= 0 &&
                              value.toInt() < _historicalData!.length) {
                            final date = _historicalData![value.toInt()].timestamp;
                            return Padding(
                              padding: const EdgeInsets.only(top: 8),
                              child: Text(
                                '${date.day}/${date.month}',
                                style: TextStyles.caption.copyWith(fontSize: 10),
                              ),
                            );
                          }
                          return const Text('');
                        },
                      ),
                    ),
                    topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                    rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                  ),
                  borderData: FlBorderData(show: true, border: Border.all(color: Colors.grey[300]!)),
                  lineBarsData: [
                    LineChartBarData(
                      spots: doDataPoints,
                      isCurved: true,
                      color: Colors.blue,
                      barWidth: 2,
                      dotData: FlDotData(show: false),
                    ),
                    LineChartBarData(
                      spots: bodDataPoints,
                      isCurved: true,
                      color: Colors.red,
                      barWidth: 2,
                      dotData: FlDotData(show: false),
                    ),
                    LineChartBarData(
                      spots: phDataPoints,
                      isCurved: true,
                      color: Colors.green,
                      barWidth: 2,
                      dotData: FlDotData(show: false),
                    ),
                  ],
                  minY: 0,
                  maxY: 15,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLegendItem(String label, Color color) {
    return Row(
      children: [
        Container(
          width: 16,
          height: 3,
          color: color,
        ),
        const SizedBox(width: 6),
        Text(label, style: TextStyles.caption.copyWith(fontSize: 12)),
      ],
    );
  }

  Widget _buildStatisticsSummary() {
    // Calculate statistics
    final wqiValues = <double>[];
    for (final reading in _historicalData!) {
      final wqiResult = CPCBWQICalculator.calculateWQI(
        ph: reading.ph,
        bod: reading.biochemicalOxygenDemand,
        dissolvedOxygen: reading.dissolvedOxygen,
        fecalColiform: reading.fecalColiform,
        waterTemperature: reading.temperature,
      );
      wqiValues.add(wqiResult.wqi);
    }

    final avgWQI = wqiValues.reduce((a, b) => a + b) / wqiValues.length;
    final maxWQI = wqiValues.reduce((a, b) => a > b ? a : b);
    final minWQI = wqiValues.reduce((a, b) => a < b ? a : b);

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('30-Day Statistics', style: TextStyles.title),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildStatCard('Average WQI', avgWQI.toStringAsFixed(1), _getWQIColor(avgWQI)),
                _buildStatCard('Maximum', maxWQI.toStringAsFixed(1), Colors.green),
                _buildStatCard('Minimum', minWQI.toStringAsFixed(1), Colors.red),
                _buildStatCard('Readings', _historicalData!.length.toString(), Colors.blue),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatCard(String label, String value, Color color) {
    return Column(
      children: [
        Text(
          value,
          style: TextStyles.title.copyWith(
            fontSize: 28,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: TextStyles.caption.copyWith(color: Colors.grey[600]),
        ),
      ],
    );
  }

  // ==================== TAB 5: HEALTH IMPACT ====================
  Widget _buildHealthImpactTab() {
    return const Center(
      child: Text('Health Impact Tab - Coming Soon'),
    );
  }

  // ==================== TAB 6: RECOMMENDATIONS ====================
  Widget _buildRecommendationsTab() {
    return const Center(
      child: Text('Recommendations Tab - Coming Soon'),
    );
  }

  // ==================== HELPER METHODS ====================
  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: TextStyles.caption.copyWith(color: Colors.grey[600])),
          Text(value, style: TextStyles.body.copyWith(fontWeight: FontWeight.w600)),
        ],
      ),
    );
  }

  /// Show real-time alerts dialog
  void _showAlertsDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            const Icon(Icons.notifications_active, color: Colors.orange),
            const SizedBox(width: 8),
            const Text('Real-time Alerts'),
          ],
        ),
        content: SizedBox(
          width: 400,
          height: 400,
          child: _realtimeAlerts.isEmpty
              ? const Center(
                  child: Text('No alerts'),
                )
              : ListView.builder(
                  itemCount: _realtimeAlerts.length,
                  itemBuilder: (context, index) {
                    final alert = _realtimeAlerts[index];
                    final severity = alert['severity'] ?? 'warning';
                    final color = severity == 'critical' ? Colors.red : 
                                  severity == 'high' ? Colors.orange : 
                                  Colors.amber;
                    
                    return Card(
                      margin: const EdgeInsets.only(bottom: 8),
                      child: ListTile(
                        leading: Icon(
                          severity == 'critical' ? Icons.error : 
                          severity == 'high' ? Icons.warning : 
                          Icons.info,
                          color: color,
                        ),
                        title: Text(
                          alert['message'] ?? 'Alert',
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                        subtitle: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            if (alert['parameter'] != null)
                              Text('Parameter: ${alert['parameter']}'),
                            if (alert['value'] != null)
                              Text('Value: ${alert['value']}'),
                            Text(
                              'Received: ${_formatAlertTime(alert['receivedAt'])}',
                              style: TextStyle(
                                fontSize: 11,
                                color: Colors.grey[600],
                              ),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              setState(() {
                _realtimeAlerts.clear();
              });
              Navigator.pop(context);
            },
            child: const Text('Clear All'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }

  String _formatAlertTime(String? timestamp) {
    if (timestamp == null) return 'Unknown';
    try {
      final dt = DateTime.parse(timestamp);
      final now = DateTime.now();
      final diff = now.difference(dt);
      
      if (diff.inMinutes < 1) return 'Just now';
      if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
      if (diff.inHours < 24) return '${diff.inHours}h ago';
      return '${diff.inDays}d ago';
    } catch (e) {
      return 'Unknown';
    }
  }

  Widget _buildEmptyState(String message) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.water_drop_outlined, size: 64, color: Colors.grey[300]),
          const SizedBox(height: 16),
          Text(
            message,
            style: TextStyles.body.copyWith(color: Colors.grey[600]),
          ),
        ],
      ),
    );
  }

  Color _getWQIColor(double wqi) {
    if (wqi >= 63) return Colors.green;
    if (wqi >= 50) return Colors.yellow[700]!;
    if (wqi >= 38) return Colors.orange;
    return Colors.red;
  }

  String _getParameterStatus(double value, String param) {
    // Simplified status logic - can be enhanced with CPCB thresholds
    switch (param) {
      case 'ph':
        if (value >= 6.5 && value <= 8.5) return 'Good';
        if (value >= 6.0 && value <= 9.0) return 'Moderate';
        return 'Poor';
      
      case 'do':
        if (value >= 6.5) return 'Good';
        if (value >= 4.0) return 'Moderate';
        return 'Poor';
      
      case 'bod':
        if (value <= 3.0) return 'Good';
        if (value <= 6.0) return 'Moderate';
        return 'Poor';
      
      case 'fc':
        if (value <= 50) return 'Good';
        if (value <= 500) return 'Moderate';
        return 'Poor';
      
      case 'tds':
        if (value <= 500) return 'Good';
        if (value <= 1000) return 'Moderate';
        return 'Poor';
      
      case 'turbidity':
        if (value <= 5) return 'Good';
        if (value <= 25) return 'Moderate';
        return 'Poor';
      
      default:
        return 'Unknown';
    }
  }

  String _formatDateTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inHours < 1) {
      return '${difference.inMinutes} minutes ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours} hours ago';
    } else {
      return '${dateTime.day}/${dateTime.month}/${dateTime.year} ${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
    }
  }
}
